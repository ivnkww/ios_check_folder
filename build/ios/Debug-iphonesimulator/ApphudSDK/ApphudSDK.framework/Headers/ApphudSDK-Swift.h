#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
#ifndef APPHUDSDK_SWIFT_H
#define APPHUDSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ApphudSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class NSString;
@protocol ApphudUIDelegate;
@class ApphudPaywall;
@class SKProduct;
@class ApphudGroup;
@class ApphudProduct;
@class ApphudPurchaseResult;
@class ApphudReceipt;
@class ApphudUserPropertyKey;
@class UIViewController;
@class ApphudRule;
@class NSData;
/// Entry point of the Apphud SDK. It provides access to all its features.
/// Main class of Apphud SDK.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.apphud.com/docs/ios">Apphud SDK Initialization</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/observer-mode">Observer Mode</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/managing-products">Fetch Products</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/making-purchases">Make a Purchase</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/checking-subscription-status">Check Subscription Status</a>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC9ApphudSDK6Apphud")
@interface Apphud : NSObject
/// Updates the user ID. Use this when you need to change the user identifier during the app’s runtime.
/// \param userID Required. The new user ID value.
///
+ (void)updateUserID:(NSString * _Nonnull)userID;
/// Returns the current userID that identifies the user across multiple devices.
/// Note: This value may change during runtime. Observe the <code>apphudDidChangeUserID(_ userID: String)</code> delegate method for changes.
+ (NSString * _Nonnull)userID SWIFT_WARN_UNUSED_RESULT;
/// Returns the current device ID. Use this method if you need to implement a custom logout/login flow by saving a User ID & Device ID pair for each app user. This allows for a more controlled management of user sessions and device associations.
///
/// returns:
/// A string representing the current device ID.
+ (NSString * _Nonnull)deviceID SWIFT_WARN_UNUSED_RESULT;
/// Logs out the current user, clears all saved data, and resets the SDK to an uninitialized state. After calling this method, you must reinitialize the SDK with <code>Apphud.start(...)</code> or <code>Apphud.manually(...)</code> for a new user.
/// This method is particularly useful in scenarios involving custom logout/login flows, allowing you to manage the subscription status of each user more effectively.
/// <em>Note</em>: If the previous user had an active subscription, a new logged-in user can still restore purchases on the same device. In this case, both users will be merged under the account of the user with the active subscription, due to the Apple ID being tied to the device.
+ (void)logoutWithCompletionHandler:(void (^ _Nonnull)(void))completionHandler;
/// Sets a UI delegate for handling UI-related interactions with the Apphud SDK.
/// \param delegate Required. An object conforming to the ApphudUIDelegate protocol. This delegate is responsible for handling UI events and interactions that arise from the SDK, such as presenting subscription screens or handling user input.
///
+ (void)setUIDelegate:(id <ApphudUIDelegate> _Nonnull)delegate;
/// Retrieves the paywalls configured in Product Hub > Paywalls, potentially altered based on the user’s involvement in A/B testing, if any. Awaits until the inner <code>SKProduct</code>s are loaded from the App Store.
/// For immediate access without awaiting <code>SKProduct</code>s, use <code>ApphudDelegate</code>’s <code>userDidLoad</code> method or the callback in <code>Apphud.start(...)</code>.
/// important:
/// This is deprecated method. Retrieve paywalls from within placements instead. See documentation for details: https://docs.apphud.com/docs/placements
/// \param maxAttempts Number of request attempts before throwing an error. Must be between 1 and 10. Default value is 3.
///
/// \param callback A closure that takes an array of <code>ApphudPaywall</code> objects and returns void.
///
/// \param error Optional ApphudError that may occur while fetching products from the App Store. You might want to retry the request if the error comes out.
///
+ (void)paywallsDidLoadCallbackWithMaxAttempts:(NSInteger)maxAttempts :(void (^ _Nonnull)(NSArray<ApphudPaywall *> * _Nonnull, NSError * _Nullable))callback SWIFT_DEPRECATED_MSG("Deprecated in favor of fetchPlacements(...)");
/// Notifies Apphud when a purchase process is initiated from a paywall in <code>Observer Mode</code>, enabling the use of A/B experiments. This method should be called right before executing your own purchase method, and it’s specifically required only when the SDK is in Observer Mode.
/// important:
/// Observer mode only. Call this method immediately before your custom purchase method.
/// Example usage:
/// \code
/// Apphud.willPurchaseProductFrom(paywallIdentifier: "main_paywall", placementIdentifier: "some_placement")
/// YourClass.purchase(someProduct)
///
/// \endcode\param paywallIdentifier Required. The Paywall ID from Apphud Product Hub > Paywalls.
///
/// \param placementIdentifier Optional. The Placement ID from Apphud Product Hub > Placements if using placements; otherwise, pass <code>nil</code>.
///
+ (void)willPurchaseProductFromPaywallIdentifier:(NSString * _Nonnull)paywallIdentifier placementIdentifier:(NSString * _Nullable)placementIdentifier;
/// Logs a “Paywall Shown” event which is required for A/B Testing analytics.
/// \param paywall The <code>ApphudPaywall</code> instance that was shown to the user.
///
+ (void)paywallShown:(ApphudPaywall * _Nonnull)paywall;
/// Logs a “Paywall Closed” event which is required for A/B Testing analytics.
/// \param paywall The <code>ApphudPaywall</code> instance that was shown to the user.
///
+ (void)paywallClosed:(ApphudPaywall * _Nonnull)paywall;
/// Fetches <code>SKProduct</code> objects asynchronously from the App Store. This method is used to retrieve the products that you have configured in the Apphud dashboard (Apphud > Product Hub > Products).
/// \param maxAttempts Number of request attempts before throwing an error. Must be between 1 and 10. Default value is 3.
///
///
/// returns:
/// An array of <code>SKProduct</code> objects corresponding to the products added in the Apphud > Product Hub > Products section.
+ (void)fetchSKProductsWithMaxAttempts:(NSInteger)maxAttempts completionHandler:(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull))completionHandler;
/// Retrieves an array of existing <code>SKProduct</code> objects or fetches products from the App Store that have been added in the Apphud Dashboard under Product Hub > Products.
/// important:
/// Best practice is to manage products using placements configurations in the Apphud Product Hub > Placements, rather than directly fetching products. Implementing placements logic via the dashboard allows for more organized and scalable management of your app’s placements and paywalls.
/// \param maxAttempts Number of request attempts before throwing an error. Must be between 1 and 10. Default value is 3.
///
/// \param callback A closure that is called upon completion. It returns an array of <code>SKProduct</code> objects and an optional <code>Error</code> if the fetch operation encountered any issues.
///
///
/// returns:
/// The method doesn’t return a value directly but instead provides the result through the <code>callback</code> parameter.
+ (void)fetchProductsWithMaxAttempts:(NSInteger)maxAttempts :(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull, NSError * _Nullable))callback;
/// Retrieves an array of <code>SKProduct</code> objects that were added in the Apphud dashboard (Apphud > Product Hub > Products). This property returns <code>nil</code> if the products have not been fetched from the App Store yet.
/// note:
/// This method returns <code>nil</code> if the products have not yet been fetched from the App Store. To ensure functionality, configure Product Hub in Apphud.
/// important:
/// As a best practice, instead of using this method directly, implement your paywall logic through the Apphud Dashboard for more effective paywall management and to leverage Apphud’s functionalities.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<SKProduct *> * _Nullable storeKitProducts;)
+ (NSArray<SKProduct *> * _Nullable)storeKitProducts SWIFT_WARN_UNUSED_RESULT;
/// Retrieves an <code>SKProduct</code> object based on its product identifier. This method is used to access product details for items you’ve added in the Apphud Dashboard under Product Hub > Products.
/// note:
/// This method will return <code>nil</code> if the product associated with the given identifier has not yet been fetched from the App Store. Ensure that your product identifiers are correctly set up in the App Store Connect and Apphud Dashboard.
/// important:
/// Best practice is to manage and retrieve products through placements configurations added in the Apphud Dashboard under Product Hub > Placements. Direct use of this method is discouraged in favor of a more structured approach to managing your app’s placements and paywalls.
/// \param productIdentifier The unique identifier for the product. Ensure this identifier matches one added in the Apphud Dashboard.
///
///
/// returns:
/// An optional <code>SKProduct</code> object corresponding to the provided identifier. Returns <code>nil</code> if the product has not been fetched from the App Store yet.
+ (SKProduct * _Nullable)productWithProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously fetches permission groups configured in the Apphud > Product Hub. Note that this method may return an empty array at the first app launch until products are loaded. Groups are cached on the device.
///
/// returns:
/// An optional array of <code>ApphudGroup</code> objects, representing the permission groups.
+ (void)permissionGroupsWithCompletionHandler:(void (^ _Nonnull)(NSArray<ApphudGroup *> * _Nullable))completionHandler;
/// Initiates the purchase of an <code>ApphudProduct</code> object from an <code>ApphudPaywall</code> and optionally from <code>ApphudPlacement</code> and automatically submits the App Store Receipt to Apphud.
/// note:
/// You can purchase products using your own code; Apphud will still receive the App Store receipt.
/// \param product Required. An <code>ApphudProduct</code> object from your <code>ApphudPaywall</code>. Configure placements and paywalls in Apphud Dashboard > Product Hub before using.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseApphudProduct:(ApphudProduct * _Nonnull)product callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Deprecated. Initiates the purchase of a product by its identifier. Use this method if you do not implement Apphud Placements logic.
/// note:
/// A/B Experiments will not work with this method. Use <code>ApphudProduct</code> objects with Placements for A/B experiments.
/// important:
/// Best practice is to use Apphud Placements configured in Apphud Dashboard > Product Hub > Placements.
/// \param productId Required. The identifier of the product to purchase.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseById:(NSString * _Nonnull)productId callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Purchases a subscription with a promotional offer and automatically submits the App Store Receipt to Apphud.
/// note:
/// This method automatically sends the in-app purchase receipt to Apphud.
/// \param apphudProduct Required. An <code>ApphudProduct</code> object representing the subscription to be purchased.
///
/// \param discountID Required. The identifier of the <code>SKProductDiscount</code> to be applied to the purchase.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object upon completion.
///
+ (void)purchasePromoWithApphudProduct:(ApphudProduct * _Nonnull)apphudProduct discountID:(NSString * _Nonnull)discountID :(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
+ (void)purchasePromo:(SKProduct * _Nonnull)skProduct discountID:(NSString * _Nonnull)discountID :(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Presents the offer code redemption sheet on iOS 14 and later. This allows users to redeem offer codes provided by Apple.
/// <ul>
///   <li>
///     Available on iOS 14.0 and later.
///   </li>
/// </ul>
+ (void)presentOfferCodeRedemptionSheet SWIFT_AVAILABILITY(ios,introduced=14.0);
/// Experimental purchase method allowing the passing of a custom value for purchases. This custom value is sent to AppsFlyer and Facebook for value optimization, such as subscription Lifetime Value (LTV) or Average Revenue Per Paying User (ARPPU), in USD.
/// note:
/// Contact your support manager for detailed guidance on using this method.
/// \param product Required. An <code>ApphudProduct</code> object for the purchase.
///
/// \param value Required. The custom value in USD to be sent for analytics.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseApphudProduct:(ApphudProduct * _Nonnull)product value:(double)value callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Sets a custom value for purchases in Observer Mode. This value is sent to AppsFlyer and Facebook for value optimization, like subscriptions LTV or ARPPU, in USD. Call this method before starting a purchase.
/// note:
/// This method is intended for use only in Observer Mode. If you are making purchases with Apphud, use the <code>purchase(_:value:callback:)</code> method.
/// important:
/// Contact your support manager for detailed guidance on using this method.
/// \param value Required. The custom value in USD.
///
/// \param productId Required. The product identifier for which the custom value is set.
///
+ (void)setCustomPurchaseValue:(double)value productId:(NSString * _Nonnull)productId;
/// Determines if the user has active premium access through a subscription or a non-renewing purchase (lifetime).
/// <em>If you have consumable purchases, do not use this method in current SDK version.</em>
/// important:
/// Do not use this method if you offer consumable in-app purchases (like coin packs) as the SDK does not differentiate consumables from non-consumables.
///
/// returns:
/// <code>true</code> if the user has an active subscription or an active non-renewing purchase.
+ (BOOL)hasPremiumAccess SWIFT_WARN_UNUSED_RESULT;
/// Checks if the user has an active premium subscription.
/// important:
/// If your app includes lifetime (non-consumable) or consumable purchases, you should use the <code>Apphud.isNonRenewingPurchaseActive(productIdentifier:)</code> method to check their status.
///
/// returns:
/// <code>true</code> if the user currently has an active subscription.
+ (BOOL)hasActiveSubscription SWIFT_WARN_UNUSED_RESULT;
/// Notification triggered when any subscription or non-renewing purchase is purchased or updated. The SDK also checks for updates when the app becomes active. This notification can be used to update the UI in response to purchase changes and is also useful in SwiftUI contexts.
///
/// returns:
/// The notification name for subscription or non-renewing purchase updates.
+ (NSNotificationName _Nonnull)didUpdateNotification SWIFT_WARN_UNUSED_RESULT;
/// Restores the user’s purchases asynchronously. This method should be called when the user taps the “Restore” button in your app.
///
/// returns:
/// An optional <code>Error</code>. If the error is <code>nil</code>, you can check the user’s premium status using the <code>Apphud.hasActiveSubscription()</code> or <code>Apphud.hasPremiumAccess()</code> methods.
+ (void)restorePurchasesWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
/// Retrieves the base64-encoded App Store receipt string, if available.
///
/// returns:
/// A base64-encoded string representing the App Store receipt, or nil if the receipt is not available.
+ (NSString * _Nullable)appStoreReceipt SWIFT_WARN_UNUSED_RESULT;
/// Fetches raw receipt information in an ApphudReceipt model class. This is useful for accessing details like the original_application_version.
/// \param completion A closure that is called with the ApphudReceipt object containing the receipt information.
///
+ (void)fetchRawReceiptInfo:(void (^ _Nonnull)(ApphudReceipt * _Nullable))completion;
/// Grants a free promotional subscription to the user. This method updates the user’s subscription status, and after this, the <code>hasActiveSubscription()</code> method will return <code>true</code>.
/// note:
/// Either <code>productId</code> (recommended) or <code>permissionGroup</code> should be passed, or both parameters can be <code>nil</code>. If both <code>productId</code> and <code>permissionGroup</code> are provided, <code>productId</code> will be used. <a href="https://docs.apphud.com/docs/product-hub">Documentation</a>
/// \param daysCount Required. The number of days for the free premium access. For a lifetime promotional, pass an extremely high value, like 100000.
///
/// \param productId Optional*. It’s recommended to provide the Product Id of the promotional subscription. Read the note below for more details.
///
/// \param permissionGroup Optional*. The Permission Group of the promotional subscription. Use this parameter if you have multiple permission groups.
///
/// \param callback Optional. Returns <code>true</code> if the promotional subscription was successfully granted.
///
+ (void)grantPromotionalWithDaysCount:(NSInteger)daysCount productId:(NSString * _Nullable)productId permissionGroup:(ApphudGroup * _Nullable)permissionGroup callback:(void (^ _Nullable)(BOOL))callback;
/// Sets a custom user property in Apphud. The value assigned to this property must be of one of the following types: <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>Bool</code>, <code>String</code>, <code>NSNumber</code>, <code>NSString</code>, <code>NSNull</code>, or <code>nil</code>.
/// Example:
/// \code
/// Apphud.setUserProperty(key: .init("custom_prop_1"), value: 0.5)
///
/// \endcodeThere are several built-in keys provided by Apphud, each expecting a specific value type:
/// <ul>
///   <li>
///     <code>.email</code>: The user’s email. The value must be a <code>String</code>.
///   </li>
///   <li>
///     <code>.name</code>: The user’s name. The value must be a <code>String</code>.
///   </li>
///   <li>
///     <code>.phone</code>: The user’s phone number. The value must be a <code>String</code>.
///   </li>
///   <li>
///     <code>.age</code>: The user’s age. The value must be an <code>Int</code>.
///   </li>
///   <li>
///     <code>.gender</code>: The user’s gender. The value must be a <code>String</code>, with accepted values being “male”, “female”, or “other”.
///   </li>
///   <li>
///     <code>.cohort</code>: The cohort the user belongs to, typically indicating when they installed the app. The value must be a <code>String</code>.
///   </li>
/// </ul>
/// Parameters:
/// <ul>
///   <li>
///     <code>key</code>: Required. This can be initialized with a custom <code>String</code> or by using one of the built-in keys provided by Apphud.
///   </li>
///   <li>
///     <code>value</code>: Required/Optional. The value to be set for the specified key. Pass <code>nil</code> or <code>NSNull</code> to remove the property from Apphud.
///   </li>
///   <li>
///     <code>setOnce</code>: Optional. A Boolean value where passing <code>true</code> will make the property non-updatable, meaning it can only be set once.
///   </li>
/// </ul>
/// Note: Custom user properties are useful for segmenting your user base within Apphud for targeted analysis or marketing efforts. Ensure the values you set are accurate and relevant to your app’s functionality and user experience.
+ (void)setUserPropertyWithKey:(ApphudUserPropertyKey * _Nonnull)key value:(id _Nullable)value setOnce:(BOOL)setOnce;
/// Increments a custom user property. Value must be one of: <code>Int</code>, <code>Float</code>, <code>Double</code> or <code>NSNumber</code>.
/// Example:
/// \code
/// Apphud.incrementUserProperty(key: .init("progress"), by: 0.5)
///
/// \endcode\param key Required. Use your custom string key or some of built-in keys.
///
/// \param by Required/Optional. You can pass negative value to decrement.
///
+ (void)incrementUserPropertyWithKey:(ApphudUserPropertyKey * _Nonnull)key by:(id _Nonnull)by;
/// Presents an Apphud Screen that was previously delayed for presentation. This is typically used in conjunction with the <code>apphudShouldShowScreen</code> delegate method, where returning <code>false</code> would delay the Screen’s presentation.
/// note:
/// Call this method to show a Screen that was delayed due to specific conditions or user actions in your app. This helps in managing the user experience more effectively, ensuring Screens are presented at the most appropriate time.
+ (void)showPendingScreen;
/// Retrieves the view controller for the Screen that is pending presentation. This screen is usually triggered by a pending Rule in Apphud. You have the option to present this Screen manually or use the <code>showPendingScreen</code> method.
/// note:
/// Use this method to retrieve the view controller for a delayed Screen if you need to present it manually or modify it before presentation.
///
/// returns:
/// An optional <code>UIViewController</code> representing the Screen that is pending for presentation. Returns <code>nil</code> if there is no Screen currently pending.
+ (UIViewController * _Nullable)pendingScreenController SWIFT_WARN_UNUSED_RESULT;
/// Retrieves the Apphud Rule associated with a Screen that was delayed for presentation.
/// note:
/// This method is useful for understanding which Rule led to the delay of a Screen and can help in making decisions on when to present the Screen or take other actions.
///
/// returns:
/// An optional <code>ApphudRule</code> object representing the Rule that triggered the delayed Screen. Returns <code>nil</code> if there is no pending Rule.
+ (ApphudRule * _Nullable)pendingRule SWIFT_WARN_UNUSED_RESULT;
/// Submits the device’s push token to Apphud. This is essential for enabling Apphud to send push notifications to the device.
/// note:
/// Ensure that the push token is obtained correctly from your app’s notification setup process before submitting it to Apphud.
/// \param token The push token, provided as a Data object.
///
/// \param callback An optional closure that returns <code>true</code> if the token was successfully sent to Apphud.
///
+ (void)submitPushNotificationsTokenWithToken:(NSData * _Nonnull)token callback:(void (^ _Nullable)(BOOL))callback;
/// Submits the device’s push token to Apphud as a String. This method provides an alternative way to submit the token if you have it in a string format.
/// note:
/// Use this method if your push token is already converted into a String format. Ensure the token is accurate for successful submission.
/// \param token The push token as a String object.
///
/// \param callback An optional closure that returns <code>true</code> if the token was successfully sent to Apphud.
///
+ (void)submitPushNotificationsTokenStringWithString:(NSString * _Nonnull)string callback:(void (^ _Nullable)(BOOL))callback;
/// Handles an incoming push notification payload. This method is used to process Rules-related notifications created by Apphud.
/// note:
/// This method should be used in your push notification handling logic to allow Apphud to manage notifications related to its Rules.
/// \param apsInfo The payload of the push notification.
///
///
/// returns:
/// <code>true</code> if the push notification was successfully handled by Apphud.
+ (BOOL)handlePushNotificationWithApsInfo:(NSDictionary * _Nonnull)apsInfo;
/// Submits Device Identifiers (IDFA and IDFV) to Apphud. These identifiers may be required for marketing and attribution platforms such as AppsFlyer, Facebook, Singular, etc.
/// Best practice is to call this method right after SDK’s <code>start(...)</code> method and once again after getting IDFA.
/// \param idfa IDFA. Identifier for Advertisers. If you request IDFA using App Tracking Transparency framework, you can call this method again after granting access.
///
/// \param idfv IDFV. Identifier for Vendor. Can be passed right after SDK’s <code>start</code> method.
///
+ (void)setDeviceIdentifiersWithIdfa:(NSString * _Nullable)idfa idfv:(NSString * _Nullable)idfv;
+ (void)setAdvertisingIdentifier:(NSString * _Nonnull)idfa SWIFT_UNAVAILABLE_MSG("'setAdvertisingIdentifier' has been renamed to 'setDeviceIdentifiersWithIdfa:idfv:'");
/// Checks whether the given product is eligible for an introductory offer, which includes <code>free trial</code>, <code>pay as you go</code>, or <code>pay up front</code> options.
/// Eligibility criteria:
/// note:
/// This check is essential for offering introductory prices correctly according to Apple’s guidelines.
/// <ul>
///   <li>
///     New subscribers are always eligible.
///   </li>
///   <li>
///     Lapsed subscribers who renew are eligible if they haven’t previously used an introductory offer for the given product or any product within the same subscription group.
///   </li>
/// </ul>
/// \param product Required. The <code>SKProduct</code> object for which you want to check introductory offer eligibility.
///
/// \param callback A closure that returns <code>true</code> if the product is eligible for an introductory offer.
///
+ (void)checkEligibilityForIntroductoryOfferWithProduct:(SKProduct * _Nonnull)product callback:(void (^ _Nonnull)(BOOL))callback;
/// Checks whether the given product is eligible for any of its promotional offers.
/// Eligibility criteria:
/// note:
/// Use this method to determine if a user can be offered a discount on a subscription renewal or upgrade.
/// <ul>
///   <li>
///     Only customers who have already purchased a subscription are eligible for promotional offers for the given product or any product within the same subscription group.
///   </li>
/// </ul>
/// \param product Required. The <code>SKProduct</code> object for which you want to check promotional offer eligibility.
///
/// \param callback A closure that returns <code>true</code> if the product is eligible for any of its promotional offers.
///
+ (void)checkEligibilityForPromotionalOfferWithProduct:(SKProduct * _Nonnull)product callback:(void (^ _Nonnull)(BOOL))callback;
/// Checks the eligibility for promotional offers for multiple products simultaneously.
/// note:
/// This method is useful for batch processing multiple products, especially when setting up a store or special offers section in your app.
/// \param products Required. An array of <code>SKProduct</code> objects for which you want to check promotional offers eligibility.
///
/// \param callback A closure that returns a dictionary with product identifiers as keys and boolean values indicating eligibility.
///
+ (void)checkEligibilitiesForPromotionalOffersWithProducts:(NSArray<SKProduct *> * _Nonnull)products callback:(void (^ _Nonnull)(NSDictionary<NSString *, NSNumber *> * _Nonnull))callback;
/// Checks the eligibility for introductory offers for multiple products simultaneously.
/// note:
/// Use this method to efficiently determine introductory offer eligibility for a range of products, aiding in dynamic pricing and offer strategies.
/// \param products Required. An array of <code>SKProduct</code> objects for which you want to check introductory offers eligibility.
///
/// \param callback A closure that returns a dictionary with product identifiers as keys and boolean values indicating eligibility.
///
+ (void)checkEligibilitiesForIntroductoryOffersWithProducts:(NSArray<SKProduct *> * _Nonnull)products callback:(void (^ _Nonnull)(NSDictionary<NSString *, NSNumber *> * _Nonnull))callback;
/// Opts the user out of tracking. This method should be called before SDK initialization. When called, it prevents the tracking of certain user parameters like IDFA, IDFV, and IP address by Apphud.
/// note:
/// Consider the privacy implications and ensure compliance with relevant data protection regulations when opting users out of tracking.
+ (void)optOutOfTracking;
/// Enables debug logs for the Apphud SDK. This method should be called before initializing the SDK.
/// note:
/// Debug logs are helpful for development and troubleshooting but should be disabled in production builds for performance and security reasons.
+ (void)enableDebugLogs;
/// Determines if the current build is running in a sandbox environment, such as during development, testing, or TestFlight, as opposed to a production App Store build.
/// note:
/// Use this method to differentiate behavior or configurations between development/testing and production environments.
///
/// returns:
/// <code>true</code> if the build is a sandbox (development, TestFlight) build; <code>false</code> if it’s an App Store build.
+ (BOOL)isSandbox SWIFT_WARN_UNUSED_RESULT;
/// Override default paywalls and placements cache timeout value. Default cache value is 9000 seconds (25 hours).
/// If expired, will make SDK to disregard cache and force refresh paywalls and placements.
/// Call it only if keeping paywalls and placements up to date is critical for your app business.
/// <em>Must call before SDK initialization.</em>
/// \param value New value in seconds. Must be between 0 and 172800 (48 hours).
///
+ (void)setPaywallsCacheTimeout:(NSTimeInterval)value;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// List of available attribution providers
/// has to make Int in order to support Objective-C
typedef SWIFT_ENUM(NSInteger, ApphudAttributionProvider, closed) {
  ApphudAttributionProviderAppsFlyer = 0,
  ApphudAttributionProviderAdjust = 1,
  ApphudAttributionProviderAppleAdsAttribution = 2,
  ApphudAttributionProviderBranch = 3,
  ApphudAttributionProviderFirebase = 4,
  ApphudAttributionProviderFacebook = 5,
  ApphudAttributionProviderSingular = 6,
  ApphudAttributionProviderTenjin = 7,
  ApphudAttributionProviderTiktok = 8,
  ApphudAttributionProviderVoluum = 9,
/// Pass custom attribution data to Apphud. Contact your support manager for details.
  ApphudAttributionProviderCustom = 10,
};

@class NSCoder;
SWIFT_CLASS("_TtC9ApphudSDK11ApphudError")
@interface ApphudError : NSError
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end

/// Apphud class which describes products permission groups
SWIFT_CLASS("_TtC9ApphudSDK11ApphudGroup")
@interface ApphudGroup : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Class for storing user data
SWIFT_CLASS("_TtC9ApphudSDK14ApphudKeychain")
@interface ApphudKeychain : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// An object associated with purchases container (Paywall).
/// Paywalls configured in Apphud Dashboard > Product Hub > Paywalls. Each paywall contains an array of <code>ApphudProduct</code> objects that you use for purchase. A paywall is a product array with custom JSON. The array is ordered and may be used to display products on your in-app purchase screen.
/// <h4>Related Articles:</h4>
/// To get paywall by identifier :
/// \code
/// let paywall = await Apphud.paywall(ApphudPaywallID.onboarding.rawValue)
///
/// \endcodenote:
/// An alternative way of getting <code>Apphud/paywalls()</code>
/// important:
/// For more information  - <a href="https://docs.apphud.com/docs/paywalls">Paywalls Documentation</a>
SWIFT_CLASS("_TtC9ApphudSDK13ApphudPaywall")
@interface ApphudPaywall : NSObject
/// Array of products
@property (nonatomic, readonly, copy) NSArray<ApphudProduct *> * _Nonnull products;
/// Your custom paywall identifier from Apphud Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// It’s possible to make a paywall default – it’s a special alias name, that can be assigned to only ONE paywall at a time. There can be no default paywalls at all. It’s up to you whether you want to have them or not.
@property (nonatomic, readonly) BOOL isDefault;
/// A/B test experiment name
@property (nonatomic, copy) NSString * _Nullable experimentName;
/// A/B Experiment Variation Name
@property (nonatomic, copy) NSString * _Nullable variationName;
/// Represents the identifier of a parent paywall from which an experiment variation was derived in A/B Experiments. This property is populated only if the ‘Use existing paywall’ option was selected during the setup of the experiment variation.
@property (nonatomic, copy) NSString * _Nullable parentPaywallIdentifier;
/// Current paywall’s placement identifier, if available.
@property (nonatomic, readonly, copy) NSString * _Nullable placementIdentifier;
/// Insert any parameters you need into custom JSON. It could be titles, descriptions, localisations, font, background and color parameters, URLs to media content, etc. Parameters count are not limited.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable json;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Apphud’s wrapper around <code>SKProduct</code>.
/// In-App Purchase must configured in App Store Connect and should be added to Apphud Dashboard > Product Hub > Products.
/// <code>ApphudProduct</code> is Apphud’s wrapper around StoreKit’s <code>SKProduct</code>.
/// note:
/// For more information  - <a href="https://docs.apphud.com/docs/product-hub">Product Hub Documentation</a>
SWIFT_CLASS("_TtC9ApphudSDK13ApphudProduct")
@interface ApphudProduct : NSObject
/// Product identifier from App Store Connect.
@property (nonatomic, readonly, copy) NSString * _Nonnull productId;
/// Product name from Apphud Dashboard
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// Always <code>app_store</code> in iOS SDK.
@property (nonatomic, readonly, copy) NSString * _Nonnull store;
/// When paywalls are successfully loaded, skProduct model will always be present if App Store returned model for this product id. getPaywalls method will return callback only when StoreKit products are fetched and mapped with Apphud products.
/// May be <code>nil</code> if product identifier is invalid, or product is not available in App Store Connect.
@property (nonatomic, readonly, strong) SKProduct * _Nullable skProduct;
/// Current product’s paywall identifier, if available.
@property (nonatomic, readonly, copy) NSString * _Nullable paywallIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable paywallId;
@property (nonatomic, readonly, copy) NSString * _Nullable placementId;
@property (nonatomic, readonly, copy) NSString * _Nullable placementIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable variationIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable experimentId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class SKPaymentTransaction;
/// General class that is returned in purchase block.
/// Using class instead of struct in order to support Objective-C
SWIFT_CLASS("_TtC9ApphudSDK20ApphudPurchaseResult")
@interface ApphudPurchaseResult : NSObject
/// Transaction from StoreKit. May be nil, if no transaction made. For example, if couldn’t sign promo offer or couldn’t get App Store receipt.
@property (nonatomic, readonly, strong) SKPaymentTransaction * _Nullable transaction;
/// This error can be of three types. Check for error class.
/// <ul>
///   <li>
///     <code>SKError</code> from StoreKit with <code>SKErrorDomain</code> codes. This is a system error when purchasing transaction.
///   </li>
///   <li>
///     <code>NSError</code> from HTTP Client with <code>NSURLErrorDomain</code> codes. This is a network/server issue when uploading receipt to Apphud.
///   </li>
///   <li>
///     Custom <code>ApphudError</code> without codes. For example, if couldn’t sign promo offer or couldn’t get App Store receipt.
///   </li>
/// </ul>
@property (nonatomic, readonly) NSError * _Nullable error;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSDate;
/// <code>ApphudReceipt</code> is Apphud’s wrapper around StoreKit’s <code>Receipt</code>.
SWIFT_CLASS("_TtC9ApphudSDK13ApphudReceipt")
@interface ApphudReceipt : NSObject
/// The version of the app that the user originally purchased. This value does not change, and corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString (in macOS) in the Info.plist file of the original purchase. In the sandbox environment, the value is always “1.0”.
/// Value is <code>nil</code> in StoreKit Testing generated receipts.
@property (nonatomic, copy) NSString * _Nullable originalApplicationVersion;
/// The time of the original app purchase. Value is <code>nil</code> in StoreKit Testing generated receipts.
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The time the App Store generated the receipt.
@property (nonatomic, readonly, copy) NSDate * _Nullable receiptCreationDate;
/// The app’s version number. The app’s version number corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString (in macOS) in the Info.plist. In production, this value is the current version of the app on the device based on the receipt_creation_date_ms. In the sandbox, the value is always “1.0”.
@property (nonatomic, copy) NSString * _Nonnull applicationVersion;
/// The bundle identifier for the app to which the receipt belongs.
@property (nonatomic, copy) NSString * _Nonnull bundleId;
/// Raw receipt JSON
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable rawJSON;
@end

/// An object containing all incoming Rule information.
SWIFT_CLASS("_TtC9ApphudSDK10ApphudRule")
@interface ApphudRule : NSObject
/// Rule name that is visible in Apphud Rules Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull rule_name;
/// Screen name that is visible in Apphud Screens Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull screen_name;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// These are three types of actions that are returned in <code>apphudScreenDismissAction(screenName: String, controller: UIViewController)</code> delegate method
typedef SWIFT_ENUM(NSInteger, ApphudScreenDismissAction, closed) {
  ApphudScreenDismissActionThankAndClose = 0,
  ApphudScreenDismissActionCloseOnly = 1,
  ApphudScreenDismissActionNone = 2,
};

/// A public protocol that provides access to Apphud’s main public methods, describing the behavior of the Rules state and custom Rules view presentation
SWIFT_PROTOCOL("_TtP9ApphudSDK16ApphudUIDelegate_")
@protocol ApphudUIDelegate
@optional
/// You can return <code>false</code> to ignore this rule. You should only do this if you want to handle your rules by yourself. Default implementation is <code>true</code>.
- (BOOL)apphudShouldPerformRuleWithRule:(ApphudRule * _Nonnull)rule SWIFT_WARN_UNUSED_RESULT;
/// You can return <code>false</code> to this delegate method if you want to delay Apphud Screen presentation.
/// Controller will be kept in memory until you present it via <code>Apphud.showPendingScreen()</code> method. If you don’t want to show screen at all, you should check <code>apphudShouldPerformRule</code> delegate method.
- (BOOL)apphudShouldShowScreenWithScreenName:(NSString * _Nonnull)screenName SWIFT_WARN_UNUSED_RESULT;
/// Return <code>UIViewController</code> instance from which you want to present given Apphud controller. If you don’t implement this method, then top visible viewcontroller from key window will be used.
/// <em>Note</em>: This delegate method is recommended for implementation when you have multiple windows in your app, because Apphud SDK may have issues while presenting screens in this case.
- (UIViewController * _Nonnull)apphudParentViewControllerWithController:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// Pass your own modal presentation style to Apphud Screens. This is useful since iOS 13 presents in page sheet style by default.
/// To get full screen style you should pass <code>.fullScreen</code> or <code>.overFullScreen</code>.
- (UIModalPresentationStyle)apphudScreenPresentationStyleWithController:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// Called when user tapped on purchase button in Apphud purchase screen.
- (void)apphudWillPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID screenName:(NSString * _Nonnull)screenName;
/// Called when user successfully purchased product in Apphud purchase screen.
- (void)apphudDidPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID screenName:(NSString * _Nonnull)screenName;
/// Called when purchase failed in Apphud purchase screen.
/// See error code for details. For example, <code>.paymentCancelled</code> error code is when user canceled the purchase by himself.
- (void)apphudDidFailPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID errorCode:(enum SKErrorCode)errorCode screenName:(NSString * _Nonnull)screenName;
/// Called when screen succesfully loaded and is visible to user.
- (void)apphudScreenDidAppearWithScreenName:(NSString * _Nonnull)screenName;
/// Called when screen is about to dismiss.
- (void)apphudScreenWillDismissWithScreenName:(NSString * _Nonnull)screenName error:(NSError * _Nullable)error;
/// Notifies that Apphud Screen did dismiss
- (void)apphudDidDismissScreenWithController:(UIViewController * _Nonnull)controller;
/// (New) Overrides action after survey option is selected or feeback sent is tapped. Default is “thankAndClose”.
/// This delegate method is only called if no other screen is selected as button action in Apphud Screens editor.
/// You can return <code>noAction</code> value and use <code>navigationController</code> property of <code>controller</code> variable to push your own view controller into hierarchy.
- (enum ApphudScreenDismissAction)apphudScreenDismissActionWithScreenName:(NSString * _Nonnull)screenName controller:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// (New) Called after survey answer is selected.
- (void)apphudDidSelectSurveyAnswerWithQuestion:(NSString * _Nonnull)question answer:(NSString * _Nonnull)answer screenName:(NSString * _Nonnull)screenName;
@end

/// User property initializer class with reserved property names.
SWIFT_CLASS("_TtC9ApphudSDK21ApphudUserPropertyKey")
@interface ApphudUserPropertyKey : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull email;)
+ (ApphudUserPropertyKey * _Nonnull)email SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull age;)
+ (ApphudUserPropertyKey * _Nonnull)age SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull phone;)
+ (ApphudUserPropertyKey * _Nonnull)phone SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull name;)
+ (ApphudUserPropertyKey * _Nonnull)name SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull gender;)
+ (ApphudUserPropertyKey * _Nonnull)gender SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull cohort;)
+ (ApphudUserPropertyKey * _Nonnull)cohort SWIFT_WARN_UNUSED_RESULT;
/// Initialize with custom property key string.
/// Example:
/// \code
/// Apphud.setUserProperty(key: .init("custom_prop_1"), value: 0.5)
///
/// \endcode
- (nonnull instancetype)init:(NSString * _Nonnull)key OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// This class will contain some utils, more will be added in the future.
SWIFT_CLASS("_TtC9ApphudSDK11ApphudUtils")
@interface ApphudUtils : NSObject
/// Disables console logging.
+ (void)enableDebugLogs;
+ (void)enableAllLogs;
+ (void)useStoreKitV2;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
#ifndef APPHUDSDK_SWIFT_H
#define APPHUDSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ApphudSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class NSString;
@protocol ApphudUIDelegate;
@class ApphudPaywall;
@class SKProduct;
@class ApphudGroup;
@class ApphudProduct;
@class ApphudPurchaseResult;
@class ApphudReceipt;
@class ApphudUserPropertyKey;
@class UIViewController;
@class ApphudRule;
@class NSData;
/// Entry point of the Apphud SDK. It provides access to all its features.
/// Main class of Apphud SDK.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.apphud.com/docs/ios">Apphud SDK Initialization</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/observer-mode">Observer Mode</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/managing-products">Fetch Products</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/making-purchases">Make a Purchase</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/docs/checking-subscription-status">Check Subscription Status</a>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC9ApphudSDK6Apphud")
@interface Apphud : NSObject
/// Updates the user ID. Use this when you need to change the user identifier during the app’s runtime.
/// \param userID Required. The new user ID value.
///
+ (void)updateUserID:(NSString * _Nonnull)userID;
/// Returns the current userID that identifies the user across multiple devices.
/// Note: This value may change during runtime. Observe the <code>apphudDidChangeUserID(_ userID: String)</code> delegate method for changes.
+ (NSString * _Nonnull)userID SWIFT_WARN_UNUSED_RESULT;
/// Returns the current device ID. Use this method if you need to implement a custom logout/login flow by saving a User ID & Device ID pair for each app user. This allows for a more controlled management of user sessions and device associations.
///
/// returns:
/// A string representing the current device ID.
+ (NSString * _Nonnull)deviceID SWIFT_WARN_UNUSED_RESULT;
/// Logs out the current user, clears all saved data, and resets the SDK to an uninitialized state. After calling this method, you must reinitialize the SDK with <code>Apphud.start(...)</code> or <code>Apphud.manually(...)</code> for a new user.
/// This method is particularly useful in scenarios involving custom logout/login flows, allowing you to manage the subscription status of each user more effectively.
/// <em>Note</em>: If the previous user had an active subscription, a new logged-in user can still restore purchases on the same device. In this case, both users will be merged under the account of the user with the active subscription, due to the Apple ID being tied to the device.
+ (void)logoutWithCompletionHandler:(void (^ _Nonnull)(void))completionHandler;
/// Sets a UI delegate for handling UI-related interactions with the Apphud SDK.
/// \param delegate Required. An object conforming to the ApphudUIDelegate protocol. This delegate is responsible for handling UI events and interactions that arise from the SDK, such as presenting subscription screens or handling user input.
///
+ (void)setUIDelegate:(id <ApphudUIDelegate> _Nonnull)delegate;
/// Retrieves the paywalls configured in Product Hub > Paywalls, potentially altered based on the user’s involvement in A/B testing, if any. Awaits until the inner <code>SKProduct</code>s are loaded from the App Store.
/// For immediate access without awaiting <code>SKProduct</code>s, use <code>ApphudDelegate</code>’s <code>userDidLoad</code> method or the callback in <code>Apphud.start(...)</code>.
/// important:
/// This is deprecated method. Retrieve paywalls from within placements instead. See documentation for details: https://docs.apphud.com/docs/placements
/// \param maxAttempts Number of request attempts before throwing an error. Must be between 1 and 10. Default value is 3.
///
/// \param callback A closure that takes an array of <code>ApphudPaywall</code> objects and returns void.
///
/// \param error Optional ApphudError that may occur while fetching products from the App Store. You might want to retry the request if the error comes out.
///
+ (void)paywallsDidLoadCallbackWithMaxAttempts:(NSInteger)maxAttempts :(void (^ _Nonnull)(NSArray<ApphudPaywall *> * _Nonnull, NSError * _Nullable))callback SWIFT_DEPRECATED_MSG("Deprecated in favor of fetchPlacements(...)");
/// Notifies Apphud when a purchase process is initiated from a paywall in <code>Observer Mode</code>, enabling the use of A/B experiments. This method should be called right before executing your own purchase method, and it’s specifically required only when the SDK is in Observer Mode.
/// important:
/// Observer mode only. Call this method immediately before your custom purchase method.
/// Example usage:
/// \code
/// Apphud.willPurchaseProductFrom(paywallIdentifier: "main_paywall", placementIdentifier: "some_placement")
/// YourClass.purchase(someProduct)
///
/// \endcode\param paywallIdentifier Required. The Paywall ID from Apphud Product Hub > Paywalls.
///
/// \param placementIdentifier Optional. The Placement ID from Apphud Product Hub > Placements if using placements; otherwise, pass <code>nil</code>.
///
+ (void)willPurchaseProductFromPaywallIdentifier:(NSString * _Nonnull)paywallIdentifier placementIdentifier:(NSString * _Nullable)placementIdentifier;
/// Logs a “Paywall Shown” event which is required for A/B Testing analytics.
/// \param paywall The <code>ApphudPaywall</code> instance that was shown to the user.
///
+ (void)paywallShown:(ApphudPaywall * _Nonnull)paywall;
/// Logs a “Paywall Closed” event which is required for A/B Testing analytics.
/// \param paywall The <code>ApphudPaywall</code> instance that was shown to the user.
///
+ (void)paywallClosed:(ApphudPaywall * _Nonnull)paywall;
/// Fetches <code>SKProduct</code> objects asynchronously from the App Store. This method is used to retrieve the products that you have configured in the Apphud dashboard (Apphud > Product Hub > Products).
/// \param maxAttempts Number of request attempts before throwing an error. Must be between 1 and 10. Default value is 3.
///
///
/// returns:
/// An array of <code>SKProduct</code> objects corresponding to the products added in the Apphud > Product Hub > Products section.
+ (void)fetchSKProductsWithMaxAttempts:(NSInteger)maxAttempts completionHandler:(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull))completionHandler;
/// Retrieves an array of existing <code>SKProduct</code> objects or fetches products from the App Store that have been added in the Apphud Dashboard under Product Hub > Products.
/// important:
/// Best practice is to manage products using placements configurations in the Apphud Product Hub > Placements, rather than directly fetching products. Implementing placements logic via the dashboard allows for more organized and scalable management of your app’s placements and paywalls.
/// \param maxAttempts Number of request attempts before throwing an error. Must be between 1 and 10. Default value is 3.
///
/// \param callback A closure that is called upon completion. It returns an array of <code>SKProduct</code> objects and an optional <code>Error</code> if the fetch operation encountered any issues.
///
///
/// returns:
/// The method doesn’t return a value directly but instead provides the result through the <code>callback</code> parameter.
+ (void)fetchProductsWithMaxAttempts:(NSInteger)maxAttempts :(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull, NSError * _Nullable))callback;
/// Retrieves an array of <code>SKProduct</code> objects that were added in the Apphud dashboard (Apphud > Product Hub > Products). This property returns <code>nil</code> if the products have not been fetched from the App Store yet.
/// note:
/// This method returns <code>nil</code> if the products have not yet been fetched from the App Store. To ensure functionality, configure Product Hub in Apphud.
/// important:
/// As a best practice, instead of using this method directly, implement your paywall logic through the Apphud Dashboard for more effective paywall management and to leverage Apphud’s functionalities.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<SKProduct *> * _Nullable storeKitProducts;)
+ (NSArray<SKProduct *> * _Nullable)storeKitProducts SWIFT_WARN_UNUSED_RESULT;
/// Retrieves an <code>SKProduct</code> object based on its product identifier. This method is used to access product details for items you’ve added in the Apphud Dashboard under Product Hub > Products.
/// note:
/// This method will return <code>nil</code> if the product associated with the given identifier has not yet been fetched from the App Store. Ensure that your product identifiers are correctly set up in the App Store Connect and Apphud Dashboard.
/// important:
/// Best practice is to manage and retrieve products through placements configurations added in the Apphud Dashboard under Product Hub > Placements. Direct use of this method is discouraged in favor of a more structured approach to managing your app’s placements and paywalls.
/// \param productIdentifier The unique identifier for the product. Ensure this identifier matches one added in the Apphud Dashboard.
///
///
/// returns:
/// An optional <code>SKProduct</code> object corresponding to the provided identifier. Returns <code>nil</code> if the product has not been fetched from the App Store yet.
+ (SKProduct * _Nullable)productWithProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously fetches permission groups configured in the Apphud > Product Hub. Note that this method may return an empty array at the first app launch until products are loaded. Groups are cached on the device.
///
/// returns:
/// An optional array of <code>ApphudGroup</code> objects, representing the permission groups.
+ (void)permissionGroupsWithCompletionHandler:(void (^ _Nonnull)(NSArray<ApphudGroup *> * _Nullable))completionHandler;
/// Initiates the purchase of an <code>ApphudProduct</code> object from an <code>ApphudPaywall</code> and optionally from <code>ApphudPlacement</code> and automatically submits the App Store Receipt to Apphud.
/// note:
/// You can purchase products using your own code; Apphud will still receive the App Store receipt.
/// \param product Required. An <code>ApphudProduct</code> object from your <code>ApphudPaywall</code>. Configure placements and paywalls in Apphud Dashboard > Product Hub before using.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseApphudProduct:(ApphudProduct * _Nonnull)product callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Deprecated. Initiates the purchase of a product by its identifier. Use this method if you do not implement Apphud Placements logic.
/// note:
/// A/B Experiments will not work with this method. Use <code>ApphudProduct</code> objects with Placements for A/B experiments.
/// important:
/// Best practice is to use Apphud Placements configured in Apphud Dashboard > Product Hub > Placements.
/// \param productId Required. The identifier of the product to purchase.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseById:(NSString * _Nonnull)productId callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Purchases a subscription with a promotional offer and automatically submits the App Store Receipt to Apphud.
/// note:
/// This method automatically sends the in-app purchase receipt to Apphud.
/// \param apphudProduct Required. An <code>ApphudProduct</code> object representing the subscription to be purchased.
///
/// \param discountID Required. The identifier of the <code>SKProductDiscount</code> to be applied to the purchase.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object upon completion.
///
+ (void)purchasePromoWithApphudProduct:(ApphudProduct * _Nonnull)apphudProduct discountID:(NSString * _Nonnull)discountID :(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
+ (void)purchasePromo:(SKProduct * _Nonnull)skProduct discountID:(NSString * _Nonnull)discountID :(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Presents the offer code redemption sheet on iOS 14 and later. This allows users to redeem offer codes provided by Apple.
/// <ul>
///   <li>
///     Available on iOS 14.0 and later.
///   </li>
/// </ul>
+ (void)presentOfferCodeRedemptionSheet SWIFT_AVAILABILITY(ios,introduced=14.0);
/// Experimental purchase method allowing the passing of a custom value for purchases. This custom value is sent to AppsFlyer and Facebook for value optimization, such as subscription Lifetime Value (LTV) or Average Revenue Per Paying User (ARPPU), in USD.
/// note:
/// Contact your support manager for detailed guidance on using this method.
/// \param product Required. An <code>ApphudProduct</code> object for the purchase.
///
/// \param value Required. The custom value in USD to be sent for analytics.
///
/// \param callback Optional. Returns an <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseApphudProduct:(ApphudProduct * _Nonnull)product value:(double)value callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Sets a custom value for purchases in Observer Mode. This value is sent to AppsFlyer and Facebook for value optimization, like subscriptions LTV or ARPPU, in USD. Call this method before starting a purchase.
/// note:
/// This method is intended for use only in Observer Mode. If you are making purchases with Apphud, use the <code>purchase(_:value:callback:)</code> method.
/// important:
/// Contact your support manager for detailed guidance on using this method.
/// \param value Required. The custom value in USD.
///
/// \param productId Required. The product identifier for which the custom value is set.
///
+ (void)setCustomPurchaseValue:(double)value productId:(NSString * _Nonnull)productId;
/// Determines if the user has active premium access through a subscription or a non-renewing purchase (lifetime).
/// <em>If you have consumable purchases, do not use this method in current SDK version.</em>
/// important:
/// Do not use this method if you offer consumable in-app purchases (like coin packs) as the SDK does not differentiate consumables from non-consumables.
///
/// returns:
/// <code>true</code> if the user has an active subscription or an active non-renewing purchase.
+ (BOOL)hasPremiumAccess SWIFT_WARN_UNUSED_RESULT;
/// Checks if the user has an active premium subscription.
/// important:
/// If your app includes lifetime (non-consumable) or consumable purchases, you should use the <code>Apphud.isNonRenewingPurchaseActive(productIdentifier:)</code> method to check their status.
///
/// returns:
/// <code>true</code> if the user currently has an active subscription.
+ (BOOL)hasActiveSubscription SWIFT_WARN_UNUSED_RESULT;
/// Notification triggered when any subscription or non-renewing purchase is purchased or updated. The SDK also checks for updates when the app becomes active. This notification can be used to update the UI in response to purchase changes and is also useful in SwiftUI contexts.
///
/// returns:
/// The notification name for subscription or non-renewing purchase updates.
+ (NSNotificationName _Nonnull)didUpdateNotification SWIFT_WARN_UNUSED_RESULT;
/// Restores the user’s purchases asynchronously. This method should be called when the user taps the “Restore” button in your app.
///
/// returns:
/// An optional <code>Error</code>. If the error is <code>nil</code>, you can check the user’s premium status using the <code>Apphud.hasActiveSubscription()</code> or <code>Apphud.hasPremiumAccess()</code> methods.
+ (void)restorePurchasesWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
/// Retrieves the base64-encoded App Store receipt string, if available.
///
/// returns:
/// A base64-encoded string representing the App Store receipt, or nil if the receipt is not available.
+ (NSString * _Nullable)appStoreReceipt SWIFT_WARN_UNUSED_RESULT;
/// Fetches raw receipt information in an ApphudReceipt model class. This is useful for accessing details like the original_application_version.
/// \param completion A closure that is called with the ApphudReceipt object containing the receipt information.
///
+ (void)fetchRawReceiptInfo:(void (^ _Nonnull)(ApphudReceipt * _Nullable))completion;
/// Grants a free promotional subscription to the user. This method updates the user’s subscription status, and after this, the <code>hasActiveSubscription()</code> method will return <code>true</code>.
/// note:
/// Either <code>productId</code> (recommended) or <code>permissionGroup</code> should be passed, or both parameters can be <code>nil</code>. If both <code>productId</code> and <code>permissionGroup</code> are provided, <code>productId</code> will be used. <a href="https://docs.apphud.com/docs/product-hub">Documentation</a>
/// \param daysCount Required. The number of days for the free premium access. For a lifetime promotional, pass an extremely high value, like 100000.
///
/// \param productId Optional*. It’s recommended to provide the Product Id of the promotional subscription. Read the note below for more details.
///
/// \param permissionGroup Optional*. The Permission Group of the promotional subscription. Use this parameter if you have multiple permission groups.
///
/// \param callback Optional. Returns <code>true</code> if the promotional subscription was successfully granted.
///
+ (void)grantPromotionalWithDaysCount:(NSInteger)daysCount productId:(NSString * _Nullable)productId permissionGroup:(ApphudGroup * _Nullable)permissionGroup callback:(void (^ _Nullable)(BOOL))callback;
/// Sets a custom user property in Apphud. The value assigned to this property must be of one of the following types: <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>Bool</code>, <code>String</code>, <code>NSNumber</code>, <code>NSString</code>, <code>NSNull</code>, or <code>nil</code>.
/// Example:
/// \code
/// Apphud.setUserProperty(key: .init("custom_prop_1"), value: 0.5)
///
/// \endcodeThere are several built-in keys provided by Apphud, each expecting a specific value type:
/// <ul>
///   <li>
///     <code>.email</code>: The user’s email. The value must be a <code>String</code>.
///   </li>
///   <li>
///     <code>.name</code>: The user’s name. The value must be a <code>String</code>.
///   </li>
///   <li>
///     <code>.phone</code>: The user’s phone number. The value must be a <code>String</code>.
///   </li>
///   <li>
///     <code>.age</code>: The user’s age. The value must be an <code>Int</code>.
///   </li>
///   <li>
///     <code>.gender</code>: The user’s gender. The value must be a <code>String</code>, with accepted values being “male”, “female”, or “other”.
///   </li>
///   <li>
///     <code>.cohort</code>: The cohort the user belongs to, typically indicating when they installed the app. The value must be a <code>String</code>.
///   </li>
/// </ul>
/// Parameters:
/// <ul>
///   <li>
///     <code>key</code>: Required. This can be initialized with a custom <code>String</code> or by using one of the built-in keys provided by Apphud.
///   </li>
///   <li>
///     <code>value</code>: Required/Optional. The value to be set for the specified key. Pass <code>nil</code> or <code>NSNull</code> to remove the property from Apphud.
///   </li>
///   <li>
///     <code>setOnce</code>: Optional. A Boolean value where passing <code>true</code> will make the property non-updatable, meaning it can only be set once.
///   </li>
/// </ul>
/// Note: Custom user properties are useful for segmenting your user base within Apphud for targeted analysis or marketing efforts. Ensure the values you set are accurate and relevant to your app’s functionality and user experience.
+ (void)setUserPropertyWithKey:(ApphudUserPropertyKey * _Nonnull)key value:(id _Nullable)value setOnce:(BOOL)setOnce;
/// Increments a custom user property. Value must be one of: <code>Int</code>, <code>Float</code>, <code>Double</code> or <code>NSNumber</code>.
/// Example:
/// \code
/// Apphud.incrementUserProperty(key: .init("progress"), by: 0.5)
///
/// \endcode\param key Required. Use your custom string key or some of built-in keys.
///
/// \param by Required/Optional. You can pass negative value to decrement.
///
+ (void)incrementUserPropertyWithKey:(ApphudUserPropertyKey * _Nonnull)key by:(id _Nonnull)by;
/// Presents an Apphud Screen that was previously delayed for presentation. This is typically used in conjunction with the <code>apphudShouldShowScreen</code> delegate method, where returning <code>false</code> would delay the Screen’s presentation.
/// note:
/// Call this method to show a Screen that was delayed due to specific conditions or user actions in your app. This helps in managing the user experience more effectively, ensuring Screens are presented at the most appropriate time.
+ (void)showPendingScreen;
/// Retrieves the view controller for the Screen that is pending presentation. This screen is usually triggered by a pending Rule in Apphud. You have the option to present this Screen manually or use the <code>showPendingScreen</code> method.
/// note:
/// Use this method to retrieve the view controller for a delayed Screen if you need to present it manually or modify it before presentation.
///
/// returns:
/// An optional <code>UIViewController</code> representing the Screen that is pending for presentation. Returns <code>nil</code> if there is no Screen currently pending.
+ (UIViewController * _Nullable)pendingScreenController SWIFT_WARN_UNUSED_RESULT;
/// Retrieves the Apphud Rule associated with a Screen that was delayed for presentation.
/// note:
/// This method is useful for understanding which Rule led to the delay of a Screen and can help in making decisions on when to present the Screen or take other actions.
///
/// returns:
/// An optional <code>ApphudRule</code> object representing the Rule that triggered the delayed Screen. Returns <code>nil</code> if there is no pending Rule.
+ (ApphudRule * _Nullable)pendingRule SWIFT_WARN_UNUSED_RESULT;
/// Submits the device’s push token to Apphud. This is essential for enabling Apphud to send push notifications to the device.
/// note:
/// Ensure that the push token is obtained correctly from your app’s notification setup process before submitting it to Apphud.
/// \param token The push token, provided as a Data object.
///
/// \param callback An optional closure that returns <code>true</code> if the token was successfully sent to Apphud.
///
+ (void)submitPushNotificationsTokenWithToken:(NSData * _Nonnull)token callback:(void (^ _Nullable)(BOOL))callback;
/// Submits the device’s push token to Apphud as a String. This method provides an alternative way to submit the token if you have it in a string format.
/// note:
/// Use this method if your push token is already converted into a String format. Ensure the token is accurate for successful submission.
/// \param token The push token as a String object.
///
/// \param callback An optional closure that returns <code>true</code> if the token was successfully sent to Apphud.
///
+ (void)submitPushNotificationsTokenStringWithString:(NSString * _Nonnull)string callback:(void (^ _Nullable)(BOOL))callback;
/// Handles an incoming push notification payload. This method is used to process Rules-related notifications created by Apphud.
/// note:
/// This method should be used in your push notification handling logic to allow Apphud to manage notifications related to its Rules.
/// \param apsInfo The payload of the push notification.
///
///
/// returns:
/// <code>true</code> if the push notification was successfully handled by Apphud.
+ (BOOL)handlePushNotificationWithApsInfo:(NSDictionary * _Nonnull)apsInfo;
/// Submits Device Identifiers (IDFA and IDFV) to Apphud. These identifiers may be required for marketing and attribution platforms such as AppsFlyer, Facebook, Singular, etc.
/// Best practice is to call this method right after SDK’s <code>start(...)</code> method and once again after getting IDFA.
/// \param idfa IDFA. Identifier for Advertisers. If you request IDFA using App Tracking Transparency framework, you can call this method again after granting access.
///
/// \param idfv IDFV. Identifier for Vendor. Can be passed right after SDK’s <code>start</code> method.
///
+ (void)setDeviceIdentifiersWithIdfa:(NSString * _Nullable)idfa idfv:(NSString * _Nullable)idfv;
+ (void)setAdvertisingIdentifier:(NSString * _Nonnull)idfa SWIFT_UNAVAILABLE_MSG("'setAdvertisingIdentifier' has been renamed to 'setDeviceIdentifiersWithIdfa:idfv:'");
/// Checks whether the given product is eligible for an introductory offer, which includes <code>free trial</code>, <code>pay as you go</code>, or <code>pay up front</code> options.
/// Eligibility criteria:
/// note:
/// This check is essential for offering introductory prices correctly according to Apple’s guidelines.
/// <ul>
///   <li>
///     New subscribers are always eligible.
///   </li>
///   <li>
///     Lapsed subscribers who renew are eligible if they haven’t previously used an introductory offer for the given product or any product within the same subscription group.
///   </li>
/// </ul>
/// \param product Required. The <code>SKProduct</code> object for which you want to check introductory offer eligibility.
///
/// \param callback A closure that returns <code>true</code> if the product is eligible for an introductory offer.
///
+ (void)checkEligibilityForIntroductoryOfferWithProduct:(SKProduct * _Nonnull)product callback:(void (^ _Nonnull)(BOOL))callback;
/// Checks whether the given product is eligible for any of its promotional offers.
/// Eligibility criteria:
/// note:
/// Use this method to determine if a user can be offered a discount on a subscription renewal or upgrade.
/// <ul>
///   <li>
///     Only customers who have already purchased a subscription are eligible for promotional offers for the given product or any product within the same subscription group.
///   </li>
/// </ul>
/// \param product Required. The <code>SKProduct</code> object for which you want to check promotional offer eligibility.
///
/// \param callback A closure that returns <code>true</code> if the product is eligible for any of its promotional offers.
///
+ (void)checkEligibilityForPromotionalOfferWithProduct:(SKProduct * _Nonnull)product callback:(void (^ _Nonnull)(BOOL))callback;
/// Checks the eligibility for promotional offers for multiple products simultaneously.
/// note:
/// This method is useful for batch processing multiple products, especially when setting up a store or special offers section in your app.
/// \param products Required. An array of <code>SKProduct</code> objects for which you want to check promotional offers eligibility.
///
/// \param callback A closure that returns a dictionary with product identifiers as keys and boolean values indicating eligibility.
///
+ (void)checkEligibilitiesForPromotionalOffersWithProducts:(NSArray<SKProduct *> * _Nonnull)products callback:(void (^ _Nonnull)(NSDictionary<NSString *, NSNumber *> * _Nonnull))callback;
/// Checks the eligibility for introductory offers for multiple products simultaneously.
/// note:
/// Use this method to efficiently determine introductory offer eligibility for a range of products, aiding in dynamic pricing and offer strategies.
/// \param products Required. An array of <code>SKProduct</code> objects for which you want to check introductory offers eligibility.
///
/// \param callback A closure that returns a dictionary with product identifiers as keys and boolean values indicating eligibility.
///
+ (void)checkEligibilitiesForIntroductoryOffersWithProducts:(NSArray<SKProduct *> * _Nonnull)products callback:(void (^ _Nonnull)(NSDictionary<NSString *, NSNumber *> * _Nonnull))callback;
/// Opts the user out of tracking. This method should be called before SDK initialization. When called, it prevents the tracking of certain user parameters like IDFA, IDFV, and IP address by Apphud.
/// note:
/// Consider the privacy implications and ensure compliance with relevant data protection regulations when opting users out of tracking.
+ (void)optOutOfTracking;
/// Enables debug logs for the Apphud SDK. This method should be called before initializing the SDK.
/// note:
/// Debug logs are helpful for development and troubleshooting but should be disabled in production builds for performance and security reasons.
+ (void)enableDebugLogs;
/// Determines if the current build is running in a sandbox environment, such as during development, testing, or TestFlight, as opposed to a production App Store build.
/// note:
/// Use this method to differentiate behavior or configurations between development/testing and production environments.
///
/// returns:
/// <code>true</code> if the build is a sandbox (development, TestFlight) build; <code>false</code> if it’s an App Store build.
+ (BOOL)isSandbox SWIFT_WARN_UNUSED_RESULT;
/// Override default paywalls and placements cache timeout value. Default cache value is 9000 seconds (25 hours).
/// If expired, will make SDK to disregard cache and force refresh paywalls and placements.
/// Call it only if keeping paywalls and placements up to date is critical for your app business.
/// <em>Must call before SDK initialization.</em>
/// \param value New value in seconds. Must be between 0 and 172800 (48 hours).
///
+ (void)setPaywallsCacheTimeout:(NSTimeInterval)value;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// List of available attribution providers
/// has to make Int in order to support Objective-C
typedef SWIFT_ENUM(NSInteger, ApphudAttributionProvider, closed) {
  ApphudAttributionProviderAppsFlyer = 0,
  ApphudAttributionProviderAdjust = 1,
  ApphudAttributionProviderAppleAdsAttribution = 2,
  ApphudAttributionProviderBranch = 3,
  ApphudAttributionProviderFirebase = 4,
  ApphudAttributionProviderFacebook = 5,
  ApphudAttributionProviderSingular = 6,
  ApphudAttributionProviderTenjin = 7,
  ApphudAttributionProviderTiktok = 8,
  ApphudAttributionProviderVoluum = 9,
/// Pass custom attribution data to Apphud. Contact your support manager for details.
  ApphudAttributionProviderCustom = 10,
};

@class NSCoder;
SWIFT_CLASS("_TtC9ApphudSDK11ApphudError")
@interface ApphudError : NSError
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end

/// Apphud class which describes products permission groups
SWIFT_CLASS("_TtC9ApphudSDK11ApphudGroup")
@interface ApphudGroup : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Class for storing user data
SWIFT_CLASS("_TtC9ApphudSDK14ApphudKeychain")
@interface ApphudKeychain : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// An object associated with purchases container (Paywall).
/// Paywalls configured in Apphud Dashboard > Product Hub > Paywalls. Each paywall contains an array of <code>ApphudProduct</code> objects that you use for purchase. A paywall is a product array with custom JSON. The array is ordered and may be used to display products on your in-app purchase screen.
/// <h4>Related Articles:</h4>
/// To get paywall by identifier :
/// \code
/// let paywall = await Apphud.paywall(ApphudPaywallID.onboarding.rawValue)
///
/// \endcodenote:
/// An alternative way of getting <code>Apphud/paywalls()</code>
/// important:
/// For more information  - <a href="https://docs.apphud.com/docs/paywalls">Paywalls Documentation</a>
SWIFT_CLASS("_TtC9ApphudSDK13ApphudPaywall")
@interface ApphudPaywall : NSObject
/// Array of products
@property (nonatomic, readonly, copy) NSArray<ApphudProduct *> * _Nonnull products;
/// Your custom paywall identifier from Apphud Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// It’s possible to make a paywall default – it’s a special alias name, that can be assigned to only ONE paywall at a time. There can be no default paywalls at all. It’s up to you whether you want to have them or not.
@property (nonatomic, readonly) BOOL isDefault;
/// A/B test experiment name
@property (nonatomic, copy) NSString * _Nullable experimentName;
/// A/B Experiment Variation Name
@property (nonatomic, copy) NSString * _Nullable variationName;
/// Represents the identifier of a parent paywall from which an experiment variation was derived in A/B Experiments. This property is populated only if the ‘Use existing paywall’ option was selected during the setup of the experiment variation.
@property (nonatomic, copy) NSString * _Nullable parentPaywallIdentifier;
/// Current paywall’s placement identifier, if available.
@property (nonatomic, readonly, copy) NSString * _Nullable placementIdentifier;
/// Insert any parameters you need into custom JSON. It could be titles, descriptions, localisations, font, background and color parameters, URLs to media content, etc. Parameters count are not limited.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable json;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Apphud’s wrapper around <code>SKProduct</code>.
/// In-App Purchase must configured in App Store Connect and should be added to Apphud Dashboard > Product Hub > Products.
/// <code>ApphudProduct</code> is Apphud’s wrapper around StoreKit’s <code>SKProduct</code>.
/// note:
/// For more information  - <a href="https://docs.apphud.com/docs/product-hub">Product Hub Documentation</a>
SWIFT_CLASS("_TtC9ApphudSDK13ApphudProduct")
@interface ApphudProduct : NSObject
/// Product identifier from App Store Connect.
@property (nonatomic, readonly, copy) NSString * _Nonnull productId;
/// Product name from Apphud Dashboard
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// Always <code>app_store</code> in iOS SDK.
@property (nonatomic, readonly, copy) NSString * _Nonnull store;
/// When paywalls are successfully loaded, skProduct model will always be present if App Store returned model for this product id. getPaywalls method will return callback only when StoreKit products are fetched and mapped with Apphud products.
/// May be <code>nil</code> if product identifier is invalid, or product is not available in App Store Connect.
@property (nonatomic, readonly, strong) SKProduct * _Nullable skProduct;
/// Current product’s paywall identifier, if available.
@property (nonatomic, readonly, copy) NSString * _Nullable paywallIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable paywallId;
@property (nonatomic, readonly, copy) NSString * _Nullable placementId;
@property (nonatomic, readonly, copy) NSString * _Nullable placementIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable variationIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable experimentId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class SKPaymentTransaction;
/// General class that is returned in purchase block.
/// Using class instead of struct in order to support Objective-C
SWIFT_CLASS("_TtC9ApphudSDK20ApphudPurchaseResult")
@interface ApphudPurchaseResult : NSObject
/// Transaction from StoreKit. May be nil, if no transaction made. For example, if couldn’t sign promo offer or couldn’t get App Store receipt.
@property (nonatomic, readonly, strong) SKPaymentTransaction * _Nullable transaction;
/// This error can be of three types. Check for error class.
/// <ul>
///   <li>
///     <code>SKError</code> from StoreKit with <code>SKErrorDomain</code> codes. This is a system error when purchasing transaction.
///   </li>
///   <li>
///     <code>NSError</code> from HTTP Client with <code>NSURLErrorDomain</code> codes. This is a network/server issue when uploading receipt to Apphud.
///   </li>
///   <li>
///     Custom <code>ApphudError</code> without codes. For example, if couldn’t sign promo offer or couldn’t get App Store receipt.
///   </li>
/// </ul>
@property (nonatomic, readonly) NSError * _Nullable error;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSDate;
/// <code>ApphudReceipt</code> is Apphud’s wrapper around StoreKit’s <code>Receipt</code>.
SWIFT_CLASS("_TtC9ApphudSDK13ApphudReceipt")
@interface ApphudReceipt : NSObject
/// The version of the app that the user originally purchased. This value does not change, and corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString (in macOS) in the Info.plist file of the original purchase. In the sandbox environment, the value is always “1.0”.
/// Value is <code>nil</code> in StoreKit Testing generated receipts.
@property (nonatomic, copy) NSString * _Nullable originalApplicationVersion;
/// The time of the original app purchase. Value is <code>nil</code> in StoreKit Testing generated receipts.
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The time the App Store generated the receipt.
@property (nonatomic, readonly, copy) NSDate * _Nullable receiptCreationDate;
/// The app’s version number. The app’s version number corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString (in macOS) in the Info.plist. In production, this value is the current version of the app on the device based on the receipt_creation_date_ms. In the sandbox, the value is always “1.0”.
@property (nonatomic, copy) NSString * _Nonnull applicationVersion;
/// The bundle identifier for the app to which the receipt belongs.
@property (nonatomic, copy) NSString * _Nonnull bundleId;
/// Raw receipt JSON
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable rawJSON;
@end

/// An object containing all incoming Rule information.
SWIFT_CLASS("_TtC9ApphudSDK10ApphudRule")
@interface ApphudRule : NSObject
/// Rule name that is visible in Apphud Rules Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull rule_name;
/// Screen name that is visible in Apphud Screens Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull screen_name;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// These are three types of actions that are returned in <code>apphudScreenDismissAction(screenName: String, controller: UIViewController)</code> delegate method
typedef SWIFT_ENUM(NSInteger, ApphudScreenDismissAction, closed) {
  ApphudScreenDismissActionThankAndClose = 0,
  ApphudScreenDismissActionCloseOnly = 1,
  ApphudScreenDismissActionNone = 2,
};

/// A public protocol that provides access to Apphud’s main public methods, describing the behavior of the Rules state and custom Rules view presentation
SWIFT_PROTOCOL("_TtP9ApphudSDK16ApphudUIDelegate_")
@protocol ApphudUIDelegate
@optional
/// You can return <code>false</code> to ignore this rule. You should only do this if you want to handle your rules by yourself. Default implementation is <code>true</code>.
- (BOOL)apphudShouldPerformRuleWithRule:(ApphudRule * _Nonnull)rule SWIFT_WARN_UNUSED_RESULT;
/// You can return <code>false</code> to this delegate method if you want to delay Apphud Screen presentation.
/// Controller will be kept in memory until you present it via <code>Apphud.showPendingScreen()</code> method. If you don’t want to show screen at all, you should check <code>apphudShouldPerformRule</code> delegate method.
- (BOOL)apphudShouldShowScreenWithScreenName:(NSString * _Nonnull)screenName SWIFT_WARN_UNUSED_RESULT;
/// Return <code>UIViewController</code> instance from which you want to present given Apphud controller. If you don’t implement this method, then top visible viewcontroller from key window will be used.
/// <em>Note</em>: This delegate method is recommended for implementation when you have multiple windows in your app, because Apphud SDK may have issues while presenting screens in this case.
- (UIViewController * _Nonnull)apphudParentViewControllerWithController:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// Pass your own modal presentation style to Apphud Screens. This is useful since iOS 13 presents in page sheet style by default.
/// To get full screen style you should pass <code>.fullScreen</code> or <code>.overFullScreen</code>.
- (UIModalPresentationStyle)apphudScreenPresentationStyleWithController:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// Called when user tapped on purchase button in Apphud purchase screen.
- (void)apphudWillPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID screenName:(NSString * _Nonnull)screenName;
/// Called when user successfully purchased product in Apphud purchase screen.
- (void)apphudDidPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID screenName:(NSString * _Nonnull)screenName;
/// Called when purchase failed in Apphud purchase screen.
/// See error code for details. For example, <code>.paymentCancelled</code> error code is when user canceled the purchase by himself.
- (void)apphudDidFailPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID errorCode:(enum SKErrorCode)errorCode screenName:(NSString * _Nonnull)screenName;
/// Called when screen succesfully loaded and is visible to user.
- (void)apphudScreenDidAppearWithScreenName:(NSString * _Nonnull)screenName;
/// Called when screen is about to dismiss.
- (void)apphudScreenWillDismissWithScreenName:(NSString * _Nonnull)screenName error:(NSError * _Nullable)error;
/// Notifies that Apphud Screen did dismiss
- (void)apphudDidDismissScreenWithController:(UIViewController * _Nonnull)controller;
/// (New) Overrides action after survey option is selected or feeback sent is tapped. Default is “thankAndClose”.
/// This delegate method is only called if no other screen is selected as button action in Apphud Screens editor.
/// You can return <code>noAction</code> value and use <code>navigationController</code> property of <code>controller</code> variable to push your own view controller into hierarchy.
- (enum ApphudScreenDismissAction)apphudScreenDismissActionWithScreenName:(NSString * _Nonnull)screenName controller:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// (New) Called after survey answer is selected.
- (void)apphudDidSelectSurveyAnswerWithQuestion:(NSString * _Nonnull)question answer:(NSString * _Nonnull)answer screenName:(NSString * _Nonnull)screenName;
@end

/// User property initializer class with reserved property names.
SWIFT_CLASS("_TtC9ApphudSDK21ApphudUserPropertyKey")
@interface ApphudUserPropertyKey : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull email;)
+ (ApphudUserPropertyKey * _Nonnull)email SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull age;)
+ (ApphudUserPropertyKey * _Nonnull)age SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull phone;)
+ (ApphudUserPropertyKey * _Nonnull)phone SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull name;)
+ (ApphudUserPropertyKey * _Nonnull)name SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull gender;)
+ (ApphudUserPropertyKey * _Nonnull)gender SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull cohort;)
+ (ApphudUserPropertyKey * _Nonnull)cohort SWIFT_WARN_UNUSED_RESULT;
/// Initialize with custom property key string.
/// Example:
/// \code
/// Apphud.setUserProperty(key: .init("custom_prop_1"), value: 0.5)
///
/// \endcode
- (nonnull instancetype)init:(NSString * _Nonnull)key OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// This class will contain some utils, more will be added in the future.
SWIFT_CLASS("_TtC9ApphudSDK11ApphudUtils")
@interface ApphudUtils : NSObject
/// Disables console logging.
+ (void)enableDebugLogs;
+ (void)enableAllLogs;
+ (void)useStoreKitV2;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
